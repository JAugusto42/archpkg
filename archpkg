#!/usr/bin/env ruby

require 'open-uri'
require 'json'
require 'rubygems/package'
require 'zlib'

# #[TODOS]#################
# Funcionar depois refatorar o código
# Associar o package com o número para que, em vez de passar o número, passe o pacote correspondente.
# Usar variaveis globais
# Adicionar mais extenções como .deb .zip para baixar um pacote e ele tera que verificar
# Um por um analisando a resposta 200 da url e baixar =D
# Atualizar o metodo de instalação de pacotes, usando shell script ta feio.
# Modularizar a aplicãção, separando update, remove, install e seach em pequenos modulos.

#FIXME Se entrar nomes compostos na busca ele nao pega o segundo nome ( ARGV )

class Main
  def initialize
    raise 'Requires ruby >= 2.4.0' if RUBY_VERSION < '2.4.0'

    case ARGV[0]
    when '-S'
      install_pkg

    when '-Ss'
      search

    when '-h'
      help

    when '--help'
      help

    else
      option = ARGV[0]
      puts "Invalid option --#{option}"
      puts "Try './archpkg --help' for more information."
    end
  end

  def update
    # TODO
  end

  def remove
    # TODO
  end

  def install_pkg

    pkg = ARGV[1]
    editor = ENV['EDITOR']

    raise "EDITOR environment variable is not set" if editor.nil?

    download_dir = '/tmp/'
    base_download_url = "https://aur.archlinux.org/cgit/aur.git/snapshot/#{pkg}.tar.gz"
    pkgbuild_url = "https://aur.archlinux.org/cgit/aur.git/tree/PKGBUILD?h=#{pkg}"

    raise 'Specify the AUR package you want to build\nUsage: archpkg -S [package]' if pkg.nil?

    puts ":: Installing #{pkg} from aur"

    puts `curl -o /tmp/#{pkg}.tar.gz #{base_download_url}`

    Dir.chdir '/tmp/'

    tar_longlink = '././@LongLink'
    tar_gz_archive = "#{pkg}.tar.gz"
    destination = '.'
    begin
      Gem::Package::TarReader.new(Zlib::GzipReader.open(tar_gz_archive)) do |tar|
        dest = nil
        tar.each do |entry|
          if entry.full_name == tar_longlink
            dest = File.join destination, entry.read.strip
            next
          end
          dest ||= File.join destination, entry.full_name
          if entry.directory?
            FileUtils.rm_rf dest unless File.directory? dest
            FileUtils.mkdir_p dest, mode: entry.header.mode, verbose: false
          elsif entry.file?
            FileUtils.rm_rf dest unless File.file? dest
            File.open dest, 'wb' do |f|
              f.print entry.read
            end
            FileUtils.chmod entry.header.mode, dest, verbose: false
          elsif entry.header.typeflag == '2'
            File.symlink entry.header.linkname, dest
          end
          dest = nil
        end
      end
    rescue Zlib::GzipFile::Error => error
      puts "#{error.class}: #{error}"
      exit
    end

    puts `rm #{pkg}.tar.gz`

    Dir.chdir "/tmp/#{pkg}"

    puts ":: Edit #{pkg} PKGBUILD? [Y/n]"
    system("#{editor} PKGBUILD") unless STDIN.gets.chomp.upcase == 'N'
    puts `makepkg -csi`

    Dir.chdir "/tmp/"
    puts `rm -r #{pkg}`

  end

  def search
    packages_local = Dir.children('/var/lib/pacman/local') # get only packages names

    pkg = ARGV[1]

    puts ":: Seaching #{pkg} on aur..."
    url = "https://aur.archlinux.org/rpc/?v=5&type=search&arg=#{pkg}"
    buffer = open(url).read
    obj = JSON.parse(buffer)
    packages = obj['resultcount']
    packages_name = obj['results']

    names = packages_name.map { |result| result['Name'] }
    version = packages_name.map { |result| result['Version'] }
    description = packages_name.map { |result| result['Description'] }

    puts ":: Found #{packages} packages"
    count = 1
    exit unless packages > 0
    while count < packages
      name_and_version = "#{names[count]}-#{version[count]}"
      check = print("\e[1;34mInstalled\e[0m ") if packages_local.include?(name_and_version)
      puts ":: \e[1;32m#{count}\e[0m aur/#{names[count]} \e[0;32m#{version[count]}\e[0m #{check}"
      puts "  #{description[count]}"
      count += 1
    end
    # range = (0..count).to_a
    # input_packages = STDIN.gets.chomp.to_i
    # install_pkg(input_packages) if range.include?(input_packages)
  end

  def help
    puts <<-HEREDOC

  Usage:
    -Ss <package>   Find a package
    -S  <package>   Install a package ( IN DEVELOPMENT )
    HEREDOC
  end
end

main = Main.new
