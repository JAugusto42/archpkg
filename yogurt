#!/usr/bin/env ruby

# Creator: Jose Augusto
# Create date: 20/08/2018
# Last update: 03/02/2019
# Contribuitors: Esdras Tarsis, brazilian ruby community.


# #[TODOS]#################
# Funcionar depois refatorar o código
# Associar o package com o número para que, em vez de passar o número, passe o pacote correspondente.
# Adicionar mais extenções como .deb .zip para baixar um pacote e ele tera que verificar
# Um por um analisando a resposta 200 da url e baixar =D
# Adicionar suporte ao out of date packages no aur

# gems
require 'open-uri'
require 'json'
require 'rubygems/package'
require 'zlib'
require 'fileutils'

class Main

  def initialize
    raise 'Requires ruby >= 2.4.0' if RUBY_VERSION <= '2.4.0'

    str = ARGV[0].to_s

    if ARGV.empty?
      update
    elsif str[0] != '-'
      search
    end

    case ARGV[0]
    when '-S'
      install_pkg

    when '-U'
      update

    when '-h', '--help'
      help

    else
      option = ARGV[0].to_s
      if option[0] == '-'
        puts "Invalid option #{option}"
        puts "Try './yogurt --help' for more information."
        exit
      end
    end
  end


  def install_pkg
    if ARGV[1].nil?
      puts 'You have to specify a package from aur repository. Usage: yogurt -S package'
      exit
    elsif ARGV[2]
      puts 'You must specify the exact name of the package, use yogurt -Ss [package] or yogurt package name without spaces'
      exit
    else
      pkg = ARGV[1]
    end

    editor = 'nano' # TODO: ask for what editor want to use.

    raise 'EDITOR environment variable is not set' if editor.nil?

    base_download_url = "https://aur.archlinux.org/cgit/aur.git/snapshot/#{pkg}.tar.gz"

    puts ":: Installing #{pkg} from aur"

    system(`curl -o /tmp/#{pkg}.tar.gz #{base_download_url}`) # TODO: get package with ruby, not curl

    Dir.chdir '/tmp/'

    tar_longlink = '././@LongLink'
    tar_gz_archive = "#{pkg}.tar.gz"
    destination = '.'
    begin
      Gem::Package::TarReader.new(Zlib::GzipReader.open(tar_gz_archive)) do |tar|
        dest = nil
        tar.each do |entry|
          if entry.full_name == tar_longlink
            dest = File.join destination, entry.read.strip
            next
          end
          dest ||= File.join destination, entry.full_name
          if entry.directory?
            FileUtils.rm_rf dest unless File.directory? dest
            FileUtils.mkdir_p dest, mode: entry.header.mode, verbose: false
          elsif entry.file?
            FileUtils.rm_rf dest unless File.file? dest
            File.open dest, 'wb' do |f|
              f.print entry.read
            end
            FileUtils.chmod entry.header.mode, dest, verbose: false
          elsif entry.header.typeflag == '2'
            File.symlink entry.header.linkname, dest
          end
          dest = nil
        end
      end
    rescue Zlib::GzipFile::Error => error
      puts "#{error.class}: #{error}"
      exit
    end

    File.delete("#{pkg}.tar.gz")

    Dir.chdir "/tmp/#{pkg}"

    puts ":: Edit #{pkg} PKGBUILD? [Y/n]"
    system("#{editor} PKGBUILD") unless STDIN.gets.chomp.casecmp('N').zero?
    system('makepkg -csi')

    Dir.chdir '/tmp/'
    FileUtils.rm_r pkg.to_s
  end


  def check_editor

  end


  def search
    packages_local = Dir.children('/var/lib/pacman/local') # get only packages names

    if ARGV[0].nil?
      puts 'You have to specify a package to search like yogurt -Ss package name'
      exit

    elsif ARGV[1].nil?
      pkg = ARGV[0]

    elsif ARGV[2].nil?
      pkg = "#{ARGV[0]}-#{ARGV[1]}"

    elsif ARGV[3].nil?
      pkg = "#{ARGV[0]}-#{ARGV[1]}-#{ARGV[2]}"

    elsif ARGV[4].nil?
      pkg = "#{ARGV[0]}-#{ARGV[1]}-#{ARGV[2]}-#{ARGV[3]}"

    else
      pkg = "#{ARGV[0]}-#{ARGV[1]}-#{ARGV[2]}-#{ARGV[3]}-#{ARGV[4]}"
    end

    puts ":: Seaching #{pkg} on aur..."
    url = "https://aur.archlinux.org/rpc/?v=5&type=search&arg=#{pkg}"
    buffer = open(url).read
    obj = JSON.parse(buffer)
    packages = obj['resultcount']
    packages_name = obj['results']

    names = packages_name.map { |result| result['Name'] }
    version = packages_name.map { |result| result['Version'] }
    description = packages_name.map { |result| result['Description'] }

    puts ":: Found #{packages} packages"
    count = 0
    count_to_show = 1
    exit unless packages > count
    while count < packages
      name_and_version = "#{names[count]}-#{version[count]}"
      check = printf("\e[1;34mInstalled\e[0m ") if packages_local.include?(name_and_version)
      puts ":: \e[1;32m#{count_to_show}\e[0m aur/#{names[count]} \e[0;32m#{version[count]}\e[0m #{check}"
      puts "  #{description[count]}"
      count += 1
      count_to_show += 1
    end
  end

  def update_package(pkg_name)
    base_url = "https://aur.archlinux.org/cgit/aur.git/snapshot/#{pkg_name}.tar.gz"
    puts base_url
    puts ":: Update #{pkg_name} from aur..."
    system(`curl -o /tmp/#{pkg_name}.tar.gz #{base_url}`) # TODO: found a simple way to get the pkg with ruby
    Dir.chdir '/tmp/'

    tar_longlink = '././@LongLink'
    tar_gz_archive = "#{pkg_name}.tar.gz"
    destination = '.'
    begin
      Gem::Package::TarReader.new(Zlib::GzipReader.open(tar_gz_archive)) do |tar|
        dest = nil
        tar.each do |entry|
          if entry.full_name == tar_longlink
            dest = File.join destination, entry.read.strip
            next
          end
          dest ||= File.join destination, entry.full_name
          if entry.directory?
            FileUtils.rm_rf dest unless File.directory? dest
            FileUtils.mkdir_p dest, mode: entry.header.mode, verbose: false
          elsif entry.file?
            FileUtils.rm_rf dest unless File.file? dest
            File.open dest, 'wb' do |f|
              f.print entry.read
            end
            FileUtils.chmod entry.header.mode, dest, verbose: false
          elsif entry.header.typeflag == '2'
            File.symlink entry.header.linkname, dest
          end
          dest = nil
        end
      end
    rescue Zlib::GzipFile::Error => error
      puts "#{error.class}: #{error}"
      exit
    end

    File.delete("#{pkg_name}.tar.gz")

    Dir.chdir "/tmp/#{pkg_name}"

    #c= clear, s= sync dependencies, i= install
    system('makepkg -csi')

    Dir.chdir '/tmp/'
    FileUtils.rm_r pkg_name.to_s
  end

  def update
    puts ':: Searching updates on official repositories...'
    system('sudo pacman -Syu')
    puts ':: Searching for aur packages updates...'
    aur_local_pkgs = `pacman -Qm`
    aur_pkg_array = aur_local_pkgs.split("\n")
    aur_pkg_array.each do |pkg_name|
      name_aur_pkg = pkg_name.to_s.split[0] # get name package
      pkg_local_version = pkg_name.to_s.split[1] # get local packages version

      url = "https://aur.archlinux.org/rpc/?v=5&type=info&arg=#{name_aur_pkg}"
      buffer = open(url).read
      obj = JSON.parse(buffer)
      packages_name = obj['results']
      name = packages_name.map { |result| result['Name'] }
      version = packages_name.map { |result| result['Version'] }
      aur_version = version[0]

      if pkg_local_version != aur_version
        puts ":: An update was found for #{name_aur_pkg}"
        puts 'Continue [Yn]?'
        answer = gets.chomp

        answer == 'Y' || answer == 'y' ? update_package(name) : exit
      else
        puts ':: No updates was found for aur repository.'
        exit
      end
    end
  end

  def help
      puts <<-HEREDOC
Usage:
    yogurt
    yogurt <operation> [...]
    yogurt <package>

operations:
    yogurt {-h --help}
    yogurt {-V --version}
    yogurt {-S --sync}        [package(s)]
    yogurt {-U --upgrade}

If no arguments are provided 'yogurt -Syu' will be performed
HEREDOC
  end

end

Main.new